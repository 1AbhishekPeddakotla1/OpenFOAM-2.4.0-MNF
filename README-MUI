The MUI coupling library* has been integrated fundamentally into OpenFOAM (and can therefore be used in any application) and a new controller architecture has been created for mdFoamPlus and dsmcFoamPlus to allow its use.

General MUI coupling is achieved using the following new source files:

src/finiteVolume/cfdTools/general/include:
	* fvCoupling.H (includes coupling[n]d header files for general use)

src/OpenFOAM/include:
	* createCouplingData.H (creates 3 coupling objects that contain 1d, 2d and 3d coupling interfaces)
	* createCouplings.H (reads coupling data from a new dictionary file at system/couplingDict (example provided in appendix A below) and creates MUI interfaces, storing them into the objects created in createCouplingData.H)

src/OpenFOAM/coupling:
	* coupling1d/coupling1d.C (creates 1 or more 1D MUI coupling interfaces with URIs equal to "mpi://[couplingName name from couplingDict]/[interfaceNames values from couplingDict OneD section]")
	* coupling1d/coupling1d.H
	* coupling2d/coupling2d.C (creates 1 or more 2D MUI coupling interfaces with URIs equal to "mpi://[couplingName name from couplingDict]/[interfaceNames values from couplingDict TwoD section]")
	* coupling2d/coupling2d.H
	* coupling3d/coupling3d.C (creates 1 or more 3D MUI coupling interfaces with URIs equal to "mpi://[couplingName name from couplingDict]/[interfaceNames values from couplingDict ThreeD section]")
	* coupling3d/coupling3d.H

There are also a number of alterations to the PStream class and a few others but these do not need to be worried about by the general developer.

A number of modifications have also been made to the ThirdParty scripts to allow the MUI library to be included in all required paths. Effectively however, inclusion of MUI in a build is achieved by:
	* Ensuring a copy of the MUI folder is in the base of the ThirdParty folder before ./Allwmake is run (this will create a copy in platforms/$ARCH$WM_COMPILER/MUI, the name of the MUI folder can be changed if required in the makeMUI script and also in the OpenFOAM script at $WM_PROJECT_DIR/etc/config/MUI.sh (or MUI.csh if not using bash), this follows the standard OpenFOAM way of working with libraries).
	* Ensuring that the new wmake rule-set "linux64GccMNF-MUI" is in use (this is set as the default, however it can be changed in the file $WM_PROJECT_DIR/etc/prefs.sh) or that the rule-set you are using includes the new general switch "-DUSE_MUI", without this the MUI library will not be used during the build, effectively making the new coupling libraries into dummies.

To use MUI in an OpenFOAM application, the general additions are as follows:
	1) Add MUI and MPI library paths to your applications "options" Make file at Make/options (this requires the ThirdParty folder to have been successfully run and to have found MUI as this sets system variables). An example updated file for building the standard laplacianFoam solver (applications/solvers/basic/laplacianFoam) can be seen in Appendix B.
	2) Include the fvCoupling.H header file in your application. This should be done after the main OpenFOAM header (i.e. fvCFD.H in most cases):
		2.1) #ifdef USE_MUI
		     	#include "fvCoupling.H"
		     #endif
	3) Include the mui.h header file in your application, this should be done AFTER any existing header includes and should be wrapped in an ifdef to ensure it is not included if -DUSE_MUI is not passed during compilation:
		3.1) #ifdef USE_MUI
		     	#include "mui.h"
		     #endif
	4) Include the new data and couplings creation headers, these should be included AFTER any existing "createXXX.H" files such as createTime.H (not that a new runtime parameter is parsed to determine whether to create couplings or not, this is actually a new switch "-coupled", which allows a MUI-compiled application to be run either with or without coupling enabled:
		4.1) #ifdef USE_MUI
		     	#include "createCouplingData.H"

				if (args.cplRunControl().cplRun())
				{
					#include "createCouplings.H"
				}
		     #endif
	5) Important final step: Include the coupling delletion header at the END of the application. Without this the MUI interface objects will not be deleted on application exit, meaning MPI_Finalize will never be called if MUI is handling that. This should be called before the final "return 0" of the application:
		5.1) #ifdef USE_MUI
			 	#include "deleteCouplings.H"
			 #endif

Assuming the above are added then you now have access to MUI interfaces in the objects created by "createCouplingData.H", which are named "couplingInterface1d", "couplingInterface2d" and "couplingInterface3d" respectively (these will be empty if no interfaces are specified in the corresponding section of the couplingDict dictionary). The objects data structures are defined in the header files coupling1d.H, coupling2d.H and coupling3d.H respectively. This gives access to the following data:
	1) word domainName (this is the value of "couplingName" in the couplingDict dictionary)	
	2) coupling[n]d* interface (this is a pointer to an instance of the coupling[n]d Class, which itself wraps the appropriate MUI uniface constructs.

The coupling[n]d classes consist of a single constructor (which does most of the work) and 3 public access functions:
	1) getInterface(int index): This is what needs to be called to access a MUI interface at a specified index. 
	2) size(): This returns the number of intefaces stored in the object.
	3) getInterfaceName(int index): This returns the name of the interface stored at a specified indec.
Therefore a simple example of accessing the MUI "push" function for the two 3D interfaces defined in Appendix A (ifs_1 & ifs_2) would be:
	1) word dataName = "exampleData";
	   mui::point3d examplePoint(0.0,0.0,0.0);
	   scalar data = 1.0;
	   scalar time = 0.0;
	   std::cout << "Domain Name: " << couplingInterface3d.domainName << std::endl;
	   for (size_t ifs = 0; i < couplingInterface3d->interfaces.size(); i++)
	   {	   		
	   		std::cout << "Interface Name: " << couplingInterface3d->interfaces.getInterfaceName(i) << std::endl;
	   		couplingInterface3d->interfaces.getInterface(i)->push(dataName, examplePoint, data);
	   }
	   couplingInterface3d->interfaces.getInterface(i)->commit(time);
	
::::::::::::::::::::::: Appendix A - couplingDict example :::::::::::::::::::::::

/*---------------------------------------------------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2.4.0-MNF                             |
|   \\  /    A nd           | Web:      http://www.openfoam.org               |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/

FoamFile
{
    version         2.0;
    format          ascii;

    root            "";
    case            "";
    instance        "";
    local           "";

    class           dictionary;
    object          couplingDict;
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

couplingName mdFoamPlus_domain1; //MUI domain name

couplingConfigurations
( 
    OneD //1D MUI coupling interface names
    {
	
    }

    TwoD //2D MUI coupling interface names
    {
        
    }

    ThreeD //3D MUI coupling interface names
    {
        interfaceNames (ifs_1 ifs_2);
    }
);

// ************************************************************************* //

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::: Appendix B - Make/options example :::::::::::::::::::::::

sinclude $(GENERAL_RULES)/mplib$(WM_MPLIB) << This is new 
sinclude $(RULES)/mplib$(WM_MPLIB) << This is new 
sinclude $(GENERAL_RULES)/MUI << This is new 

EXE_INC = \
    $(PFLAGS) \ << This is new 
    $(PINC) \ << This is new 
    ${MUI_INC} \ << This is new 
    -I$(LIB_SRC)/finiteVolume/lnInclude \
    -I$(LIB_SRC)/meshTools/lnInclude

EXE_LIBS = \
    $(PLIBS) \ << This is new 
    -lfiniteVolume \
    -lmeshTools

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

* Tang Y.-H., Kudo, S., Bian, X., Li, Z., & Karniadakis, G. E. Multiscale Universal Interface: A Concurrent Framework for Coupling Heterogeneous Solvers, Journal of Computational Physics, 2015, 297.15, 13-31.
